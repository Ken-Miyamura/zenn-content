---
title: "GormのUpdateメソッドを使う際の落とし穴"
emoji: "🕳️"
type: "tech"
topics: ["Go", "Gorm", "ORM", "Database", "SQL"]
published: false
---

## はじめに

![](https://www.genspark.ai/api/files/s/XA9KJ7uo?cache_control=3600)

こんにちは!Goでバックエンド開発を行っている皆さん、データベース操作で予期しない動作に遭遇したことはありませんか?

本記事では、GoのORMライブラリとして広く使われている**GORM**の`Update`メソッドを使用する際に遭遇する、**boolean型のfalse値や数値型の0などのゼロ値が更新されない**という落とし穴について解説します。

この問題は、GORMの仕様を理解していないと遭遇しやすく、実際に私も開発中にハマってしまった経験があります。本記事を通じて、同じ問題で悩む方の助けになれば幸いです。

**本記事で学べること:**
- GORMの基本的な仕組み
- Updateメソッドでゼロ値が更新されない理由
- 具体的な解決方法
- 代替となるORM(Bun)の紹介

それでは、順を追って見ていきましょう!

## GORMとは?

![](https://www.genspark.ai/api/files/s/jCJqBibv?cache_control=3600)

**GORM**は、Go言語で最も人気のあるORM(Object-Relational Mapping)ライブラリです。ORMとは、オブジェクト指向プログラミングとリレーショナルデータベースの間でデータをマッピングする技術のことを指します。

### GORMの特徴

- **フル機能のORM**: CRUD操作、マイグレーション、リレーションシップなど、必要な機能がすべて揃っています
- **開発者フレンドリー**: 直感的なAPIで、SQLを書かずにデータベース操作が可能
- **多様なデータベース対応**: PostgreSQL、MySQL、SQLite、SQL Serverなどをサポート
- **アソシエーション**: Has One、Has Many、Belongs To、Many to Manyなどの関連付けに対応

### 基本的な使い方

```go
type User struct {
    ID        uint   `gorm:"primaryKey"`
    Name      string
    Email     string
    IsActive  bool
    Age       int
}

// レコードの作成
db.Create(&User{Name: "田中太郎", Email: "tanaka@example.com", IsActive: true, Age: 30})

// レコードの取得
var user User
db.First(&user, 1)

// レコードの更新
db.Model(&user).Update("Name", "佐藤花子")
```

公式ドキュメント: [GORM - The fantastic ORM library for Golang](https://gorm.io/)

一見シンプルで使いやすそうですが、実は**Update**メソッドには注意すべき挙動があります。

## false値でUpdateメソッドを使ったらうまく更新されなかった話

![](https://www.genspark.ai/api/files/s/82dgKD8v?cache_control=3600)

### 遭遇した問題

あるプロジェクトで、ユーザーのアクティブ状態を管理する機能を実装していました。`IsActive`というboolean型のフィールドを`true`から`false`に更新しようとしたところ、**データベースが更新されない**という問題に直面しました。

```go
type User struct {
    ID        uint   `gorm:"primaryKey"`
    Name      string
    Email     string
    IsActive  bool   // これをfalseに更新したい
    Age       int
}

// ユーザーのアクティブ状態をfalseに更新しようとする
user := User{ID: 1}
db.Model(&user).Updates(User{IsActive: false})

// しかし、データベースは更新されない...!
```

同様に、数値型の`Age`を`0`に更新しようとしても更新されませんでした。

```go
// 年齢を0に更新しようとする
db.Model(&user).Updates(User{Age: 0})

// これも更新されない...!
```

### なぜ更新されないのか?

GORM公式ドキュメントの[Updates](https://gorm.io/docs/update.html)セクションに、この挙動について明記されています:

> **NOTE:** When updating with struct, GORM will only update non-zero fields. You might want to use `map` to update attributes or use `Select` to specify fields to update

つまり、**構造体を使ってUpdateやUpdatesを呼び出すと、GORMはゼロ値(zero value)のフィールドを無視する**という仕様があるのです。

Goにおけるゼロ値は以下の通りです:
- `bool`: `false`
- `int`, `int64`など: `0`
- `string`: `""`
- `pointer`: `nil`
- `time.Time`: `0001-01-01 00:00:00 +0000 UTC`

これは、意図しない更新を防ぐための設計ですが、**明示的にゼロ値に更新したい場合には問題となります**。

### 実際のSQLを確認

```go
// 以下のコードは
db.Model(&user).Updates(User{Name: "山田太郎", IsActive: false, Age: 0})

// 以下のようなSQLを生成します
// UPDATE users SET name = '山田太郎' WHERE id = 1
// IsActiveとAgeは更新されない!
```

この仕様を知らずに使うと、「なぜ更新されないんだ?」と悩むことになります。私もこの問題でかなり時間を費やしてしまいました...😭

## 解決方法

![](https://www.genspark.ai/api/files/s/MdZWblxj?cache_control=3600)

この問題には、いくつかの解決方法があります。それぞれの方法を見ていきましょう。

### 方法1: map[string]interface{}を使う

最も直接的な解決方法は、構造体の代わりに`map[string]interface{}`を使うことです。

```go
db.Model(&user).Updates(map[string]interface{}{
    "is_active": false,
    "age": 0,
})
```

この方法では、GORMはゼロ値も含めてすべての値を更新します。

**メリット:**
- シンプルで分かりやすい
- 確実にゼロ値を更新できる

**デメリット:**
- 型安全性が失われる
- タイプミスに気づきにくい
- IDEの補完が効かない

### 方法2: Select()メソッドを使う

`Select()`メソッドを使うと、更新するフィールドを明示的に指定できます。

```go
db.Model(&user).Select("IsActive", "Age").Updates(User{
    IsActive: false,
    Age: 0,
})
```

または、すべてのフィールドを更新する場合は:

```go
db.Model(&user).Select("*").Updates(User{
    Name: "山田太郎",
    IsActive: false,
    Age: 0,
})
```

**メリット:**
- 型安全性が保たれる
- 構造体を使える
- 更新するフィールドを明示的にコントロールできる

**デメリット:**
- 少しコードが長くなる

### 方法3: Update()メソッドで単一フィールドを更新

単一のフィールドだけを更新する場合は、`Update()`メソッドが使えます。

```go
db.Model(&user).Update("is_active", false)
db.Model(&user).Update("age", 0)
```

**メリット:**
- 単一フィールドの更新には最もシンプル
- ゼロ値も問題なく更新できる

**デメリット:**
- 複数フィールドを更新する場合は複数回呼び出す必要がある

### 推奨する方法

個人的には、**方法2のSelect()メソッドを使う方法**をおすすめします。理由は以下の通りです:

1. **型安全性**: コンパイル時にエラーを検出できる
2. **明示性**: どのフィールドを更新するか明確
3. **保守性**: 構造体定義と連動するため、リファクタリングしやすい

```go
// おすすめの書き方
db.Model(&user).Select("IsActive", "Age").Updates(User{
    IsActive: false,
    Age: 0,
})
```

### ※あとがき(執筆者追記用)

<!-- ここにあなたのコメントや追加情報を記載してください -->

公式ドキュメント: [GORM Update Documentation](https://gorm.io/docs/update.html)

## 代替手法: BunというGoのORMの紹介

![](https://www.genspark.ai/api/files/s/UHKYrDD6?cache_control=3600)

GORMの落とし穴を経験した後、**Bun**という別のGoのORMライブラリについても調査してみました。Bunは比較的新しいORMですが、興味深い特徴を持っています。

### Bunとは?

**Bun**は、**SQL-first**のアプローチを採用したGoのORMライブラリです。「SQLを隠すのではなく、SQLを活用する」という哲学の下に開発されています。

公式サイト: [Bun: The SQL-first Golang ORM](https://bun.uptrace.dev/)

### Bunの特徴

1. **SQL-firstアプローチ**: 生成されるSQLが予測可能
2. **高パフォーマンス**: 生SQLに近い性能
3. **型安全**: コンパイル時の型チェック
4. **柔軟性**: 必要に応じて生SQLも使える
5. **段階的導入**: 既存のコードベースに徐々に統合可能

### Bunでの更新処理

Bunでは、ゼロ値の更新問題はどのように扱われるのでしょうか?

```go
type User struct {
    bun.BaseModel `bun:"table:users"`

    ID       int64  `bun:",pk,autoincrement"`
    Name     string
    IsActive bool
    Age      int
}

// Bunでの更新
_, err := db.NewUpdate().
    Model(&user).
    Column("is_active", "age").
    Where("id = ?", 1).
    Exec(ctx)
```

Bunでは、明示的に`Column()`メソッドで更新するカラムを指定するため、ゼロ値の問題に遭遇しにくい設計になっています。

### GORMとBunの比較

| 項目 | GORM | Bun |
|------|------|-----|
| 哲学 | ORMファースト | SQL-first |
| ゼロ値の扱い | 構造体使用時は無視される | 明示的な指定が必要 |
| 学習曲線 | 比較的緩やか | SQLの知識が必要 |
| パフォーマンス | 良好 | より高速 |
| コミュニティ | 大きい | 成長中 |
| ドキュメント | 充実 | 充実 |

### Bunを選ぶべきケース

- SQLをしっかり理解していて、予測可能なクエリが欲しい場合
- パフォーマンスを最優先したい場合
- 既存の`database/sql`コードと統合したい場合
- 新規プロジェクトで、モダンなORMを使いたい場合

### GORMを選ぶべきケース

- 豊富なエコシステムと大きなコミュニティが必要な場合
- 迅速な開発が求められる場合
- 既存のGORMを使ったコードベースがある場合
- SQLの知識が少ないチームメンバーがいる場合

どちらのORMも優れたツールです。プロジェクトの要件やチームのスキルセットに応じて選択することをおすすめします。

公式ドキュメント: [Bun Guide](https://bun.uptrace.dev/guide/golang-orm.html)

## まとめ

![](https://www.genspark.ai/api/files/s/hmYpJF7n?cache_control=3600)

本記事では、GORMのUpdateメソッドを使う際の落とし穴について解説しました。重要なポイントをまとめます:

### 📌 重要なポイント

1. **GORMの仕様を理解する**
   - 構造体を使ったUpdatesメソッドは、ゼロ値(false、0、""など)を無視する
   - これは意図しない更新を防ぐための設計

2. **解決方法は3つ**
   - `map[string]interface{}`を使う(型安全性が失われる)
   - `Select()`メソッドで更新フィールドを明示(推奨)
   - `Update()`メソッドで単一フィールドを更新

3. **推奨する方法**
   ```go
   db.Model(&user).Select("IsActive", "Age").Updates(User{
       IsActive: false,
       Age: 0,
   })
   ```

4. **代替案としてのBun**
   - SQL-firstアプローチの新しいORM
   - ゼロ値の問題に遭遇しにくい設計
   - パフォーマンスと予測可能性を重視する場合に最適

### さいごに

ORMは便利なツールですが、その仕様や制限を理解せずに使うと、思わぬ落とし穴にハマることがあります。

今回紹介した問題は、GORMのドキュメントに明記されていますが、実際に遭遇するまで気づかないことも多いです。この記事が、同じ問題で悩んでいる方の助けになれば幸いです。

また、GORMだけでなく、Bunのような代替ORMについても知っておくことで、プロジェクトに最適なツールを選択できるようになります。

**参考リンク:**
- [GORM公式サイト](https://gorm.io/)
- [GORM Update Documentation](https://gorm.io/docs/update.html)
- [Bun公式サイト](https://bun.uptrace.dev/)
- [Bun ORM Guide](https://bun.uptrace.dev/guide/golang-orm.html)

Happy Coding! 🎉

---

最後まで読んでいただき、ありがとうございました!
この記事が役に立ったら、ぜひ「いいね」やコメントをお願いします!
